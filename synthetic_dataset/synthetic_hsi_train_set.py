import torch
import numpy as np
from PIL import Image
from synthetic_dataset.synthetic_hsi_generation import hr2lr, random_crop,ohr2lr
import cv2
import random
import torch.nn.functional as F
from cv2 import imwrite
import os


class SyntheticHSI(torch.utils.data.Dataset):
    """ Synthetic burst dataset for joint denoising, demosaicking, and super-resolution. RAW Burst sequences are
    synthetically generated on the fly as follows. First, a single image is loaded from the base_dataset. The sampled
    image is converted to linear sensor space using the inverse camera pipeline employed in [1]. A burst
    sequence is then generated by adding random translations and rotations to the converted image. The generated burst
    is then converted is then mosaicked, and corrupted by random noise to obtain the RAW burst.

    [1] Unprocessing Images for Learned Raw Denoising, Brooks, Tim and Mildenhall, Ben and Xue, Tianfan and Chen,
    Jiawen and Sharlet, Dillon and Barron, Jonathan T, CVPR 2019
    """

    def __init__(self, base_dataset, downfactor=4, crop_sz=384, gray_max=255.0, split='train', random_flip=True, random_scale=True, random_rotate=True):
        self.base_dataset = base_dataset

        self.crop_sz = crop_sz
        self.downsample_factor = downfactor
        self.interpolation_type = 'bilinear'
        self.gray_max = gray_max
        self.split = split
        self.random_flip =  random_flip
        self.random_scale = random_scale
        self.random_rotate = random_rotate
        self.offset = 16

    def __len__(self):
        return len(self.base_dataset)

    def __getitem__(self, index):

        frame = self.base_dataset[index]
        frame = torch.from_numpy(frame).float()
        frame = frame.permute(2, 0, 1)
        '''
        max_value = torch.max(frame)
        if max_value > 4096:
            frame = frame / self.gray_max
        elif max_value > 256:
            frame = frame / 4095
        else:
            frame = frame / 255
        '''
        max_value = torch.max(frame)
        frame = frame / max_value
        #frame = frame.flip([0]).contiguous()
        #frame = frame / self.gray_max
        crop_sz = self.crop_sz + 2 * self.offset #self.downsample_factor (复位)
        if self.random_flip:
            if random.random() > 0.5:
                frame = frame.flip([-1]).contiguous()  # 水平翻转，沿宽度维度
            if random.random() > 0.5:
                frame = frame.flip([-2]).contiguous()  # 垂直翻转，沿高度维度

        '''if self.random_scale:
            # 随机选择缩放因子 [1, 0.75, 0.5]
            scale_factor = random.choice([1, 0.75, 0.5])
            frame = F.interpolate(frame.unsqueeze(0), scale_factor=scale_factor, mode='bilinear', align_corners=False).squeeze(0)
        print(frame.shape)'''

        if self.random_rotate:
            # 随机选择旋转角度 [0, 90, 180, 270]
            angle = random.choice([0, 90, 180, 270])
            frame = torch.rot90(frame, k=angle // 90, dims=[1, 2])  # dims=[1, 2] 是沿着高度和宽度旋转

        # Extract a random crop from the image
        frame_crop, r1, c1 = random_crop(frame, crop_sz)
        # Generate RAW burst hsi_lr_blur,
        hsi_lr, hsi_lr_blur,flow_vectors, hsi_gt = ohr2lr(frame_crop, self.offset, self.downsample_factor, interpolation_type=self.interpolation_type)
        hsi_gt = hsi_gt[:, self.offset:-self.offset, self.offset:-self.offset]

        return hsi_lr, hsi_lr_blur,flow_vectors, hsi_gt